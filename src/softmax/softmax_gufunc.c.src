//
// softmax_gufunc.c.src
//
// gufunc implementation of softmax(x)
//
//

#define PY_SSIZE_T_CLEAN
#include "Python.h"

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#define NPY_NO_DEPRECATED_API NPY_API_VERSION
#include "numpy/ndarraytypes.h"
#include "numpy/arrayscalars.h"
#include "numpy/ufuncobject.h"

#include "../src/util/ufunc_tools.h"


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// ufunc inner loops for floating point types.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

/**begin repeat
 * #typename      = float, double, longdouble   #
 * #ctype         = float, double, long double  #
 * #suffix        = f,           , l            #
 */

static void softmax_@typename@_loop(char **args, const npy_intp *dimensions,
                                    const npy_intp* steps, void* data)
{
    // dimensions[0]: Number of input arrays
    // dimensions[1]: Length of each array
    // steps[0]:  x array step
    // steps[1]:  output array step
    // steps[2]:  inner x array step
    // steps[3]:  inner output array step
    char *px   = args[0];
    char *pout = args[1];
    npy_intp nloops = dimensions[0];
    npy_intp n      = dimensions[1];
    npy_intp x_stride         = steps[0];
    npy_intp out_stride       = steps[1];
    npy_intp x_inner_stride   = steps[2];
    npy_intp out_inner_stride = steps[3];

    for (npy_intp j = 0; j < nloops; ++j, px += x_stride, pout += out_stride) {
        // Get the maximum, and count positive infs.
        npy_intp nposinf = 0;
        npy_intp posinf_index;
        bool has_nan = false;
        @ctype@ xmax;
        for (npy_intp k = 0; k < n; ++k) {
            @ctype@ x = *((@ctype@ *) (px + k*x_inner_stride));
            if (isnan(x)) {
                has_nan = true;
                break;
            }
            if (isinf(x) && x > 0) {
                ++nposinf;
                posinf_index = k;
            }
            if (k == 0 || x > xmax) {
                xmax = x;
            }
        }
        if (has_nan || nposinf > 1) {
            // x contains nan, or there is more than one positive inf, so set the
            // result to all nan.
            for (npy_intp k = 0; k < n; ++k) {
                *((@ctype@ *) (pout + k*out_inner_stride)) = NPY_NAN;
            }
            continue;
        }
        else if (nposinf == 1) {
            for (npy_intp k = 0; k < n; ++k) {
                *((@ctype@ *) (pout + k*out_inner_stride)) = 0;
            }
            *((@ctype@ *) (pout + posinf_index*out_inner_stride)) = 1;
            continue;
        }

        @ctype@ expsum = 0.0;
        for (npy_intp k = 0; k < n; ++k) {
            expsum += exp@suffix@(*(@ctype@ *) (px + k*x_inner_stride) - xmax);
        }
        for (npy_intp k = 0; k < n; ++k) {
            @ctype@ x = *((@ctype@ *) (px + k*x_inner_stride));
            *((@ctype@ *) (pout + k*out_inner_stride)) = exp@suffix@(x - xmax) / expsum;
        }
    }
}

/**end repeat**/


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// ufunc configuration data.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// These are the input and return dtypes of softmax.
static char softmax_typecodes[] = {
    NPY_FLOAT, NPY_FLOAT,
    NPY_DOUBLE, NPY_DOUBLE,
    NPY_LONGDOUBLE, NPY_LONGDOUBLE
};

static PyUFuncGenericFunction softmax_funcs[] = {
    (PyUFuncGenericFunction) &softmax_float_loop,
    (PyUFuncGenericFunction) &softmax_double_loop,
    (PyUFuncGenericFunction) &softmax_longdouble_loop
};

#define SOFTMAX_NTYPES (sizeof(softmax_funcs)/sizeof(softmax_funcs[0]))
static void *softmax_data[SOFTMAX_NTYPES];


// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Python extension module definitions.
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

static PyMethodDef SoftmaxMethods[] = {
        {NULL, NULL, 0, NULL}
};

static struct PyModuleDef moduledef = {
    PyModuleDef_HEAD_INIT,
    .m_name = "_softmax",
    .m_doc = "Module that defines the softmax function.",
    .m_size = -1,
    .m_methods = SoftmaxMethods
};


#define SOFTMAX_DOCSTRING \
"softmax(x, /, ...)\n"                                                          \
"\n"                                                                            \
"Compute the softmax function of the 1-d array `x`.\n"                          \
"See https://en.wikipedia.org/wiki/Softmax_function for more information.\n"    \
"\n"                                                                            \
"If `x` contains `nan` or more than one positive infinity, the result is\n"     \
"all `nan`.\n"                                                                  \
"\n"                                                                            \
"Parameters\n"                                                                  \
"----------\n"                                                                  \
"x : array_like\n"                                                              \
"    Input array\n"                                                             \
"\n"                                                                            \
"Returns\n"                                                                     \
"-------\n"                                                                     \
"out : ndarray\n"                                                               \
"\n"                                                                            \
"Examples\n"                                                                    \
"--------\n"                                                                    \
">>> import numpy as np\n"                                                      \
">>> from ufunclab import softmax\n"                                            \
"\n"                                                                            \
">>> x = np.array([1.0, 10.0, 1.5, 2.0, -5.0])\n"                               \
">>> softmax(x)\n"                                                              \
"array([1.23328081e-04, 9.99337792e-01, 2.03333631e-04, 3.35240482e-04,\n"      \
"       3.05699750e-07])\n"                                                     \
"\n"

PyMODINIT_FUNC PyInit__softmax(void)
{
    PyObject *module;

    module = PyModule_Create(&moduledef);
    if (!module) {
        return NULL;
    }

    import_array();
    import_umath();

    // Create the softmax ufunc.
    if (ul_define_gufunc(module, "softmax", SOFTMAX_DOCSTRING, "(n)->(n)",
                         SOFTMAX_NTYPES,
                         softmax_funcs, softmax_data, softmax_typecodes) == NULL) {
        Py_DECREF(module);
        return NULL;
    }

    return module;
}
